
---

# 📚 資料結構專題筆記：陣列 (Array) 深度解析

## 一、 陣列的基本定義與物理特性

陣列是一種將資料儲存在**連續記憶體空間**中的集合，每個元素皆可透過索引 (Index) 直接存取 。其核心特性如下：

**固定大小與存取效率**
靜態陣列在編譯時即決定長度且無法更改 。由於記憶體位址連續，系統提供常數時間  的隨機存取效率 。

**同質性要求**
陣列內所有元素通常具備相同的資料型態，這使得位址計算法則保持一致且高效 。

**ADT 抽象資料型別定義**
在 ADT 定義中，陣列是多個 `<索引, 值>` 對的組合 。一維索引集合為  。陣列具備 `Create`（建立維度與大小）、`Retrieve`（取出值）以及 `Store`（存入值）等基本功能 。

---

## 二、 多維陣列的表示與存取邏輯

### 一維陣列 (1D Array)

一維陣列是最簡單的線性結構 。
範例：`int array[5] = {10, 20, 30, 40, 50};` 。
存取：`array[2]` 對應第三個元素，結果為 30 。

### 二維陣列 (2D Array)

二維陣列由列 (Row) 與行 (Column) 組成矩陣結構 。第一個索引代表列，第二個索引代表行 。
範例：`int array2d[3][4]` 代表 3 列 4 行 。
存取：`array2d[1][2]` 指向第 2 列、第 3 行，在講義範例中數值為 7 。

### 三維陣列 (3D Array)

三維陣列由多個平面 (Plane/Block) 堆疊而成 。
範例：`int array3d[2][3][4]` 代表 2 個平面，每個平面各為  矩陣 。
存取：`array3d[1][2][3]` 的結果為 24 。

---

## 三、 動態記憶體管理規範

### 動態陣列宣告 (Dynamic Array)

當陣列大小需在執行期 (Runtime) 決定時，必須使用指標與記憶體分配函數 。
語法範例：

```c
int *array;
array = (int *) malloc(n * sizeof(int)); // 分配記憶體
array = (int *) realloc(array, n * sizeof(int)); // 調整大小

```



### 記憶體位址變動規律

將動態陣列重新分配 (realloc) 到兩倍大小時，位址不一定保持不變 。
若原本區塊後方有足夠空間，`realloc` 會原地擴展，位址不變。但若空間不足，系統會開闢新區塊並複製資料，此時起始位址會改變 。

### 安全開發規範

開發者必須手動呼叫 `free(array)` 釋放記憶體以避免記憶體洩漏 (Memory Leak) 。
針對 `realloc` 的安全寫法應使用暫存指標，防止分配失敗回傳 `NULL` 時導致原始指標丟失，造成無法釋放空間的錯誤。

---

## 四、 基礎排序演算法實作

講義詳述了三種時間複雜度皆為  的排序法，目標均為升冪排序 (Ascending order) 。

### 泡沫排序 (Bubble Sort)

邏輯為重複比較相鄰兩元素，若左大於右則交換，最大值會逐輪移至末端 。

```c
for(int i=1; i<10; i++){
    for(int j=0; j<10-i; j++){
        if(a[j] > a[j+1]){
            int temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
        }
    }
}

```

### 選擇排序 (Selection Sort)

邏輯為從未排序區域中尋找最小值，將其與該區域起始位置的數字交換 。

```c
for(int i=0; i<10; i++){
    int min = i;
    for(int j=i+1; j<10; j++){
        if(a[j] < a[min]){
            min = j;
        }
    }
    int temp = a[min];
    a[min] = a[i];
    a[i] = temp;
}

```

### 插入排序 (Insertion Sort)

邏輯如同整理撲克牌，將元素插入左側已排序序列的正確位置 。

```c
for(int i=1; i<10; i++){
    int key = a[i];
    int j = i - 1;
    while(j>=0 && a[j] > key){
        a[j+1] = a[j];
        j--;
    }
    a[j+1] = key;
}

```

---

## 五、 搜尋演算法與效能總計

### 搜尋策略對比

線性搜尋 (Linear Search) 適用於任何陣列，需逐一檢查元素直到找到目標 。
二元搜尋 (Binary Search) 僅限於已排序陣列，透過每次砍半搜尋範圍來提升效率 。

### 操作複雜度分析

| 操作 | 時間複雜度 | 說明 |
| --- | --- | --- |
| **隨機存取 (Access)** |  | 直接透過索引計算位址 

 |
| **插入/刪除 (Insert/Delete)** |  | 需要位移其他元素以保持連續性 

 |
| **遍歷 (Traverse)** |  | 必須拜訪所有元素 

 |
| **二元搜尋 (Binary Search)** |  | 適用於已排序陣列 

 |

---

## 六、 記憶體位址計算實務 (16 進位)

記憶體位址是依據資料型態大小連續分布的。
以 `int arr[10]` 為例，假設 `sizeof(int) = 4` 且起始位址為 `0x1000` ：

* 第一個元素 `arr[0]` 位址為 `0x1000` 。


* 第二個元素 `arr[1]` 位址為 `0x1004` 。


* 最後一個元素 `arr[9]` 位址為 `0x1024` 。
終點位址公式為：`起始位址 + (陣列大小 * 單位大小) - 1` 。



---
