

# 資料結構：堆積 (Heaps)

---

## 第一部分：考試速查版 (Quick Reference)

### 1. 核心定義與性質

* **定義**
  堆積 (Heap) 是一種滿足「**堆積順序性質 (Heap-order Property)**」的
  👉 **完全二元樹 (Complete Binary Tree)**

* **結構特性（Shape Property）**

  * 除了最後一層外，每一層都是滿的
  * 最後一層節點必須 **由左至右依序填滿**

* **儲存方式**

  * 因為是完全二元樹
  * 👉 **通常使用陣列 (Array) 實作，空間利用率高**

---

### 2. 堆積類型 (Ordering)

* **最大堆積 (Max Heap)**

  ```text
  父節點 ≥ 子節點
  ```

  👉 根節點為整個堆積的 **最大值**

* **最小堆積 (Min Heap)**

  ```text
  父節點 ≤ 子節點
  ```

  👉 根節點為整個堆積的 **最小值**

---

### 3. 時間複雜度速查表（必背）

| 操作                      | 時間複雜度          | 原因                  |
| ----------------------- | -------------- | ------------------- |
| **Peek Max / Min**      | **O(1)**       | 根節點固定在 index 0      |
| **Insert (Sift-up)**    | **O(log n)**   | 沿樹高由葉節點往上           |
| **Extract (Sift-down)** | **O(log n)**   | 沿樹高由根往下             |
| **Build Heap**          | **O(n)**       | Floyd Bottom-up 演算法 |
| **Heapsort**            | **O(n log n)** | 執行 n 次 Extract      |

---

## 第二部分：課堂用詳細版本 (Detailed Notes)

---

## 一、堆積的陣列表示法 (Array Representation)

使用陣列儲存堆積（**根節點索引為 0**）時，索引關係為：

* **左子節點 (Left Child)**

  ```text
  2i + 1
  ```

* **右子節點 (Right Child)**

  ```text
  2i + 2
  ```

* **父節點 (Parent)**

  ```text
  ⌊(i − 1) / 2⌋
  ```

👉 這個索引關係 **只在完全二元樹成立**

---

## 二、核心操作邏輯 (Core Operations)

---

### 1. 插入 (Insertion / Sift-up)

**目標**：

> 插入新元素後，恢復堆積順序性質

**步驟**：

1. 將新元素放在陣列最後一格
   （保持完全二元樹形狀）
2. 與父節點比較
3. 若違反 Heap-order，則 **交換**
4. 重複直到：

   * 父節點 ≥（或 ≤）新元素
   * 或到達根節點

👉 **時間複雜度：O(log n)**

---

### 2. 移除最大 / 最小值 (Extract / Sift-down)

**目標**：

> 移除根節點，並重新維持堆積結構

**步驟**：

1. 取出根節點（Max / Min）
2. 將最後一個葉節點移到根部
3. 與 **較大的子節點（Max Heap）** 或
   **較小的子節點（Min Heap）** 比較
4. 若違反 Heap-order，則交換
5. 重複直到符合條件或到達葉節點

👉 **時間複雜度：O(log n)**

---

## 三、堆積的應用 (Applications)

---

### 1. 優先權佇列 (Priority Queue) ⭐

* 堆積是 **Priority Queue 最典型的實作方式**
* 可在：

  * **O(1)** 時間取得最高（或最低）優先權元素
  * **O(log n)** 時間插入與刪除

👉 C++：`priority_queue`

---

### 2. 堆積排序 (Heapsort)

**流程**：

1. 將 n 個元素 **Build Heap** → `O(n)`
2. 重複執行 n 次 **Extract** → `O(n log n)`

**特性**：

* 就地排序 (**In-place**)
* 不需要額外記憶體
* 最壞情況仍為 **O(n log n)**（很穩定）

---

## 四、常見考試與面試陷阱 ⭐

---

### 1. 為什麼 Build Heap 是 O(n)？

* 直覺誤判：

  ```text
  n 次 Insert → O(n log n)
  ```

* 事實：

  * Floyd 演算法採用 **Bottom-up**
  * 大多數節點位於底層
  * 下沉距離很短

👉 經由數學推導後，**總成本收斂為 O(n)**

---

### 2. Heap ≠ Binary Search Tree

* Heap **只保證父子關係**
* **不保證左右子樹的大小順序**
* 👉 不能用 Heap 做中序排序搜尋

---

### 3. 完全二元樹 ≠ 滿二元樹

* **完全二元樹 (Complete)**

  * 最後一層可不滿
  * 但必須靠左排列

* **滿二元樹 (Full)**

  * 每個節點都有 0 或 2 個子節點

👉 Heap 一定是 **Complete**，不一定是 **Full**

---

## 一句話考前總結（超好背）

> **Heap 是以完全二元樹為結構、以陣列實作的優先權資料結構，能在 O(log n) 時間內插入與刪除，在 O(1) 時間內取得最大或最小值。**

---
