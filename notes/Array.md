
---

# 📚 資料結構專題筆記：陣列 (Array) 深度解析

## 一、 陣列的基礎定義與底層邏輯

陣列是將一組元素儲存在**連續記憶體位置**的集合，每個元素可透過**索引 (Index)** 直接存取 。

* **物理特性**：
* 
**連續性**：元素在記憶體中一個接一個排列，中間無間隙 。


* 
**同質性**：通常儲存相同資料型態（如 `int` 或 `char`），以維持存取效率 。


* 
**隨機存取**：提供 **** 的常數時間存取速度 。




* **記憶體位址計算 (16進位)**：
最後一個元素的位址 = 起始位址 + (陣列大小  資料型態大小) - 1。
* **範例**：`int arr[10]`，起始位址 `0x1000`，`sizeof(int) = 4`。
* 
`arr[0]` 位址：`0x1000` 。


* 
`arr[1]` 位址：`0x1004` 。


* 
`arr[9]` 位址：`0x1024` 。





---

## 二、 陣列的抽象資料型別 (ADT)

陣列本質上是多個 `<索引, 值>` 對 (pairs) 的集合 。

* 
**索引定義**：一維為 ；二維為  。


* **核心功能實作**：
* **`Create(j, list)`**：建立一個  維陣列。`list` 為 tuple，定義每一維的大小。
* 例：`Create(2, (3,4))`  建立  的二維陣列 。




* 
**`Retrieve(A, i)`**：若 ，回傳陣列  索引  的值（支援多維表示） 。


* 
**`Store(A, i, x)`**：將值  存入陣列  的索引  處 。





---

## 三、 動態記憶體管理 (Dynamic Memory Management)

當陣列大小需在**執行期 (Runtime)** 決定時，必須使用動態分配 。

### 1. 核心指令與宣告 (C 語言)

* 
**宣告與分配**：使用 `malloc` 向 **Heap (堆區)** 申請空間 。
`int *array = (int *) malloc(n * sizeof(int));`


* 
**調整大小**：使用 `realloc` 修改容量 。
`array = (int *) realloc(array, new_size * sizeof(int));`


* 
**釋放空間**：使用完畢必須執行 `free(array)` 以避免 **Memory Leak (記憶體洩漏)** 。



### 2. `realloc` 的行為機制

當要求將容量加倍時，會發生兩種情況 ：

* **原地擴展成功**：若原區塊後方有足夠空間，起始位址不變。
* **重新配置位址**：若後方空間不足，系統會開新區塊、複製舊資料並釋放舊區塊，**起始位址會改變**。
* **安全寫法規範**：
```c
int *tmp = realloc(arr, new_size);
if (tmp == NULL) { /* 處理錯誤，arr 仍有效 */ }
else { arr = tmp; } // 成功才更新指標，避免指標變成 NULL 導致舊空間失聯。

```



---

## 四、 基礎排序演算法實作

講義介紹了三種時間複雜度皆為 **** 的基礎排序法 。

### 1. 泡沫排序 (Bubble Sort)

* 
**邏輯**：相鄰兩兩比較，若左大於右則交換，使最大值逐次「浮」向末端 。


* **關鍵程式碼**：
```c
for(int i=1; i<10; i++) {
    for(int j=0; j<10-i; j++) {
        if(a[j] > a[j+1]) { /* Swap a[j] and a[j+1] */ }
    }
}

```



### 2. 選擇排序 (Selection Sort)

* 
**邏輯**：從未排序區域找最小值，並與該區域的第一個元素交換 。


* **關鍵程式碼**：
```c
for(int i=0; i<10; i++) {
    int min = i;
    for(int j=i+1; j<10; j++) {
        if(a[j] < a[min]) min = j; // 更新最小值索引
    }
    /* Swap a[min] and a[i] */
}

```



### 3. 插入排序 (Insertion Sort)

* 
**邏輯**：模擬抽撲克牌，將「新牌」插入左側已排序區域的正確位置 。


* **關鍵程式碼**：
```c
for(int i=1; i<10; i++) {
    int key = a[i], j = i-1;
    while(j>=0 && a[j] > key) {
        a[j+1] = a[j]; // 數字後挪
        j--;
    }
    a[j+1] = key; // 插入
}

```



---

## 五、 搜尋演算法 (Search)

* **線性搜尋 (Linear Search)**：
* 
**條件**：不限有無排序 。


* 
**效能**：最壞情況為 **** 。




* **二元搜尋 (Binary Search)**：
* 
**條件**：必須是**已排序**陣列 。


* 
**做法**：每次取中間值比對，範圍砍半。效率為 **** 。





---

## 六、 效能分析與複雜度總結

| 操作 (Operation) | 時間複雜度 | 物理行為說明 |
| --- | --- | --- |
| **存取 (Access)** | **** | 基於索引隨機存取 

 |
| **更新 (Update)** | **** | 直接覆蓋指定索引值 

 |
| **插入 (Insert)** | **** | 需將插入點後方所有元素後移 

 |
| **刪除 (Delete)** | **** | 需將刪除點後方所有元素前移 

 |
| **搜尋 (Search)** | **** | 線性 (未排序) / 二元 (已排序) 

 |

### 實務應用建議：

* 
**優勢**：適合需要頻繁隨機存取、靜態資料或順序遍歷的場景（CPU 快取命中率高） 。


* 
**劣勢**：不適合頻繁在中間插入/刪除的操作 。



---
