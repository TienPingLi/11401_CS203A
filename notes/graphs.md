
---

# 資料結構：圖形 (Graphs)

---

## 第一部分：考試速查版 (Quick Reference)

### 1. 核心定義與性質

* **圖形 (Graph)**
  由

  ```text
  頂點集合 V (Vertices)
  邊集合 E (Edges)
  ```

  所組成的結構，記為

  ```text
  G = (V, E)
  ```

* **圖形類型**：

  * **無向圖 (Undirected Graph)**
    邊 (u, v) 等同於 (v, u)
  * **有向圖 (Directed Graph)**
    邊 (u, v) 具有方向性，由 u → v
  * **加權圖 (Weighted Graph)**
    邊具有權重（距離、成本、時間）

---

* **分支度 (Degree)**：

  * **無向圖**：
    節點的 Degree = 與該節點相連的邊數
  * **有向圖**：

    * **In-degree**：指向該節點的邊數
    * **Out-degree**：由該節點指出的邊數

---

### 2. 表示法效能對比（必考）

| 操作                  | 相鄰矩陣 (Adjacency Matrix) | 相鄰清單 (Adjacency List) |
| ------------------- | ----------------------- | --------------------- |
| **空間複雜度**           | **O(V²)**               | **O(V + E)**          |
| **找節點 v 的所有鄰居**     | O(V)                    | O(deg(v))             |
| **確認邊 (u, v) 是否存在** | **O(1)**                | O(deg(u))             |
| **適用場景**            | 稠密圖 (Dense Graph)       | 稀疏圖 (Sparse Graph)    |

---

### 3. 圖形遍歷 (Traversals)

* **DFS (Depth-First Search)**
  👉 使用 **Stack（堆疊）或遞迴**

* **BFS (Breadth-First Search)**
  👉 使用 **Queue（佇列）**

* **重要考點**

  ```text
  圖形遍歷一定要使用 visited[]
  否則遇到 Cycle 會無限迴圈
  ```

---

## 第二部分：課堂用詳細版本 (Detailed Notes)

---

## 一、圖形表示法：實作細節

### 1. 相鄰矩陣 (Adjacency Matrix)

* **概念**
  使用二維陣列 `A[V][V]`

  ```text
  A[i][j] = 1   → i 與 j 有邊
  A[i][j] = 0   → i 與 j 無邊
  ```

* **無向圖特性**
  👉 相鄰矩陣必為 **對稱矩陣**

* **加權圖**

  * `A[i][j] = weight`
  * 無邊處常設為 `∞` 或 `0`

---

### 2. 相鄰清單 (Adjacency List)

* **概念**
  每個頂點對應一個串列，記錄其相鄰節點

* **空間效率**
  當

  ```text
  E << V²
  ```

  時，空間使用率遠優於矩陣

* **有向圖特性**

  * 預設只記錄 **出度**
  * 若要查 In-degree，需額外建立
    👉 **逆相鄰清單 (Inverse Adjacency List)**

---

## 二、深度優先搜尋 (DFS) 深入分析

* **核心思想**
  👉 走到不能再走為止，再回溯（Backtracking）

* **演算法流程**：

1. 存取頂點 v
2. 標記 `visited[v] = true`
3. 對所有與 v 相鄰且尚未拜訪的頂點 w
   👉 遞迴執行 `DFS(w)`

---

* **時間複雜度**：

  ```text
  O(V + E)
  ```

* **常見應用**：

  * 判斷圖是否連通
  * 偵測 Cycle
  * **拓撲排序 (Topological Sort)**

    * 僅適用於 **DAG（有向無環圖）**

---

## 三、廣度優先搜尋 (BFS) 深入分析

* **核心思想**
  👉 一層一層向外擴展

* **演算法流程**：

1. 起點加入 Queue
2. 標記為 `visited`
3. 當 Queue 不為空：

   * 取出隊首 v
   * 將所有未拜訪鄰居加入 Queue 並標記

---

* **時間複雜度**：

  ```text
  O(V + E)
  ```

* **重要應用（超常考）**：

  * **最短路徑（非加權圖）**

    > BFS 第一次到達終點
    > 即為最短路徑

---

## 四、樹 (Tree) 與 圖形 (Graph) 的關鍵差異 ⭐

| 項目            | Tree    | Graph |
| ------------- | ------- | ----- |
| **Cycle**     | ❌ 無     | ✅ 可能有 |
| **連通性**       | 一定連通    | 可能不連通 |
| **路徑**        | 任兩點唯一路徑 | 可能多條  |
| **visited[]** | 通常不需要   | 一定需要  |

👉 **樹其實是「無環、連通的圖」**

---

## 五、進階應用場景（老師最愛舉例）

* **路徑規劃**

  * 節點：路口
  * 邊：道路
  * 演算法：Dijkstra / BFS

* **通訊與網路**

  * 節點：電腦 / 路由器
  * 邊：線路
  * 問題：最短路徑、最大流

* **相依性管理**

  * 套件安裝順序
  * 使用 **DAG + Topological Sort**

---

## 考前一句話總結（超好背）

> **Graph 是由頂點與邊構成的非線性結構，常以相鄰矩陣或相鄰清單表示，並透過 DFS 與 BFS 進行遍歷與分析。**

---

